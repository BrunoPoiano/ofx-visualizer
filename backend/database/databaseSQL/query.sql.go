// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package databaseSQL

import (
	"context"
	"database/sql"
)

const countBanks = `-- name: CountBanks :one
SELECT count(id)
FROM banks
WHERE (
    ?1 IS NULL
    OR name      LIKE '%' || ?1 || '%'
    OR account_id  LIKE '%' || ?1 || '%'
    OR account_type  LIKE '%' || ?1 || '%'
    OR f_id  LIKE '%' || ?1 || '%'
    OR bank_id  LIKE '%' || ?1 || '%'
    OR branch_id  LIKE '%' || ?1 || '%'
)
ORDER BY id
`

func (q *Queries) CountBanks(ctx context.Context, query interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBanks, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListBalancess = `-- name: CountListBalancess :one
SELECT count(id) FROM balances
WHERE
    (
        ?1 IS NOT NULL
        AND statement_id = ?1
    )
    OR
    (
        ?1 IS NULL
        AND (
            ?2 IS NULL
            OR name LIKE '%' || ?2 || '%'
        )
    )
ORDER BY
    CASE WHEN @order = 'name' AND @direction = 'asc'  THEN name END ASC,
    CASE WHEN @order = 'name' AND @direction = 'desc' THEN name END DESC,
    CASE WHEN @order = 'description' AND @direction = 'asc'  THEN description END ASC,
    CASE WHEN @order = 'description' AND @direction = 'desc' THEN description END DESC,
    CASE WHEN @order = 'balance_type' AND @direction = 'asc'  THEN balance_type END ASC,
    CASE WHEN @order = 'balance_type' AND @direction = 'desc' THEN balance_type END DESC,
    CASE WHEN @order = 'value' AND @direction = 'asc'  THEN value END ASC,
    CASE WHEN @order = 'value' AND @direction = 'desc' THEN value END DESC,
    CASE WHEN @order = 'statement_id' AND @direction = 'asc'  THEN statement_id END ASC,
    CASE WHEN @order = 'statement_id' AND @direction = 'desc' THEN statement_id END DESC
LIMIT ?4 OFFSET ?3
`

type CountListBalancessParams struct {
	StatementID interface{} `json:"statement_id"`
	Search      interface{} `json:"search"`
	Offset      int64       `json:"offset"`
	Limit       int64       `json:"limit"`
}

func (q *Queries) CountListBalancess(ctx context.Context, arg CountListBalancessParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countListBalancess,
		arg.StatementID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBalance = `-- name: CreateBalance :one
INSERT INTO balances (
statement_id,name,description,balance_type,value
) VALUES (
  ?, ?,?,?,?
)
RETURNING id, statement_id, name, description, balance_type, value
`

type CreateBalanceParams struct {
	StatementID sql.NullInt64  `json:"statement_id"`
	Name        interface{}    `json:"name"`
	Description sql.NullString `json:"description"`
	BalanceType interface{}    `json:"balance_type"`
	Value       float64        `json:"value"`
}

func (q *Queries) CreateBalance(ctx context.Context, arg CreateBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, createBalance,
		arg.StatementID,
		arg.Name,
		arg.Description,
		arg.BalanceType,
		arg.Value,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.StatementID,
		&i.Name,
		&i.Description,
		&i.BalanceType,
		&i.Value,
	)
	return i, err
}

const createBank = `-- name: CreateBank :one
INSERT INTO banks (
name,account_id,account_type,f_id,bank_id,branch_id
) VALUES (
  ?, ?,?,?,?,?
)
RETURNING id, name, account_id, account_type, f_id, bank_id, branch_id
`

type CreateBankParams struct {
	Name        interface{} `json:"name"`
	AccountID   interface{} `json:"account_id"`
	AccountType interface{} `json:"account_type"`
	FID         interface{} `json:"f_id"`
	BankID      interface{} `json:"bank_id"`
	BranchID    interface{} `json:"branch_id"`
}

func (q *Queries) CreateBank(ctx context.Context, arg CreateBankParams) (Bank, error) {
	row := q.db.QueryRowContext(ctx, createBank,
		arg.Name,
		arg.AccountID,
		arg.AccountType,
		arg.FID,
		arg.BankID,
		arg.BranchID,
	)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountID,
		&i.AccountType,
		&i.FID,
		&i.BankID,
		&i.BranchID,
	)
	return i, err
}

const createCard = `-- name: CreateCard :one
INSERT INTO cards (
name,account_id,f_id
) VALUES (
  ?, ?,?
)
RETURNING id, account_id, name, f_id
`

type CreateCardParams struct {
	Name      interface{} `json:"name"`
	AccountID interface{} `json:"account_id"`
	FID       interface{} `json:"f_id"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, createCard, arg.Name, arg.AccountID, arg.FID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.FID,
	)
	return i, err
}

const createSource = `-- name: CreateSource :one
INSERT INTO source (
card_id,bank_id
) VALUES (
  ?, ?
)
RETURNING id, card_id, bank_id
`

type CreateSourceParams struct {
	CardID interface{} `json:"card_id"`
	BankID interface{} `json:"bank_id"`
}

func (q *Queries) CreateSource(ctx context.Context, arg CreateSourceParams) (Source, error) {
	row := q.db.QueryRowContext(ctx, createSource, arg.CardID, arg.BankID)
	var i Source
	err := row.Scan(&i.ID, &i.CardID, &i.BankID)
	return i, err
}

const createStatement = `-- name: CreateStatement :one
INSERT INTO statements (
source_id,start_date,end_date,ledger_balance,balance_date,server_date,language
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language
`

type CreateStatementParams struct {
	SourceID      sql.NullInt64 `json:"source_id"`
	StartDate     interface{}   `json:"start_date"`
	EndDate       interface{}   `json:"end_date"`
	LedgerBalance float64       `json:"ledger_balance"`
	BalanceDate   interface{}   `json:"balance_date"`
	ServerDate    interface{}   `json:"server_date"`
	Language      interface{}   `json:"language"`
}

func (q *Queries) CreateStatement(ctx context.Context, arg CreateStatementParams) (Statement, error) {
	row := q.db.QueryRowContext(ctx, createStatement,
		arg.SourceID,
		arg.StartDate,
		arg.EndDate,
		arg.LedgerBalance,
		arg.BalanceDate,
		arg.ServerDate,
		arg.Language,
	)
	var i Statement
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.StartDate,
		&i.EndDate,
		&i.LedgerBalance,
		&i.BalanceDate,
		&i.ServerDate,
		&i.Language,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
id,source_id,date,value,type,desc
) VALUES (
  ?, ?, ?, ?, ?, ?
)
RETURNING id, source_id, date, value, type, "desc"
`

type CreateTransactionParams struct {
	ID       interface{}    `json:"id"`
	SourceID sql.NullInt64  `json:"source_id"`
	Date     interface{}    `json:"date"`
	Value    float64        `json:"value"`
	Type     interface{}    `json:"type"`
	Desc     sql.NullString `json:"desc"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.ID,
		arg.SourceID,
		arg.Date,
		arg.Value,
		arg.Type,
		arg.Desc,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Date,
		&i.Value,
		&i.Type,
		&i.Desc,
	)
	return i, err
}

const deleteBalance = `-- name: DeleteBalance :exec
DELETE FROM balances
WHERE id = ?
`

func (q *Queries) DeleteBalance(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBalance, id)
	return err
}

const deleteBank = `-- name: DeleteBank :exec
DELETE FROM banks
WHERE id = ?
`

func (q *Queries) DeleteBank(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBank, id)
	return err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM cards
WHERE id = ?
`

func (q *Queries) DeleteCard(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCard, id)
	return err
}

const deleteSource = `-- name: DeleteSource :exec
DELETE FROM source
WHERE id = ?
`

func (q *Queries) DeleteSource(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSource, id)
	return err
}

const deleteStatement = `-- name: DeleteStatement :exec
DELETE FROM statements
WHERE id = ?
`

func (q *Queries) DeleteStatement(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStatement, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions
WHERE id = ?
`

func (q *Queries) DeleteTransaction(ctx context.Context, id interface{}) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const findBalance = `-- name: FindBalance :one
SELECT id FROM balances
WHERE statement_id = ? AND name = ? AND value = ?
LIMIT 1
`

type FindBalanceParams struct {
	StatementID sql.NullInt64 `json:"statement_id"`
	Name        interface{}   `json:"name"`
	Value       float64       `json:"value"`
}

func (q *Queries) FindBalance(ctx context.Context, arg FindBalanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findBalance, arg.StatementID, arg.Name, arg.Value)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findSource = `-- name: FindSource :one
SELECT id
FROM source
WHERE (bank_id = ?1 AND card_id = 0)
   OR (bank_id = 0 AND card_id = ?2)
LIMIT 1
`

type FindSourceParams struct {
	BankID interface{} `json:"bank_id"`
	CardID interface{} `json:"card_id"`
}

func (q *Queries) FindSource(ctx context.Context, arg FindSourceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findSource, arg.BankID, arg.CardID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getBalance = `-- name: GetBalance :one
SELECT id, statement_id, name, description, balance_type, value FROM balances
WHERE id = ? LIMIT 1
`

func (q *Queries) GetBalance(ctx context.Context, id int64) (Balance, error) {
	row := q.db.QueryRowContext(ctx, getBalance, id)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.StatementID,
		&i.Name,
		&i.Description,
		&i.BalanceType,
		&i.Value,
	)
	return i, err
}

const getBank = `-- name: GetBank :one
SELECT id, name, account_id, account_type, f_id, bank_id, branch_id FROM banks
WHERE id = ? LIMIT 1
`

// -------------------- BANKS
func (q *Queries) GetBank(ctx context.Context, id int64) (Bank, error) {
	row := q.db.QueryRowContext(ctx, getBank, id)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountID,
		&i.AccountType,
		&i.FID,
		&i.BankID,
		&i.BranchID,
	)
	return i, err
}

const getBankByAccountId = `-- name: GetBankByAccountId :one
SELECT id, name, account_id, account_type, f_id, bank_id, branch_id FROM banks
WHERE account_id = ? LIMIT 1
`

func (q *Queries) GetBankByAccountId(ctx context.Context, accountID interface{}) (Bank, error) {
	row := q.db.QueryRowContext(ctx, getBankByAccountId, accountID)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountID,
		&i.AccountType,
		&i.FID,
		&i.BankID,
		&i.BranchID,
	)
	return i, err
}

const getCard = `-- name: GetCard :one

SELECT id, account_id, name, f_id FROM cards
WHERE id = ? LIMIT 1
`

// -------------------- Cards
func (q *Queries) GetCard(ctx context.Context, id int64) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.FID,
	)
	return i, err
}

const getCardByAccountId = `-- name: GetCardByAccountId :one
SELECT id FROM cards
WHERE account_id = ? LIMIT 1
`

func (q *Queries) GetCardByAccountId(ctx context.Context, accountID interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCardByAccountId, accountID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getSource = `-- name: GetSource :one

SELECT id, card_id, bank_id FROM source
WHERE id = ? LIMIT 1
`

// -------------------- Source
func (q *Queries) GetSource(ctx context.Context, id int64) (Source, error) {
	row := q.db.QueryRowContext(ctx, getSource, id)
	var i Source
	err := row.Scan(&i.ID, &i.CardID, &i.BankID)
	return i, err
}

const getStatement = `-- name: GetStatement :one

SELECT id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language FROM statements
WHERE id = ? LIMIT 1
`

// -------------------- Statements
func (q *Queries) GetStatement(ctx context.Context, id int64) (Statement, error) {
	row := q.db.QueryRowContext(ctx, getStatement, id)
	var i Statement
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.StartDate,
		&i.EndDate,
		&i.LedgerBalance,
		&i.BalanceDate,
		&i.ServerDate,
		&i.Language,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one

SELECT id, source_id, date, value, type, "desc" FROM transactions
WHERE id = ? LIMIT 1
`

// -------------------- Transactions
func (q *Queries) GetTransaction(ctx context.Context, id interface{}) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Date,
		&i.Value,
		&i.Type,
		&i.Desc,
	)
	return i, err
}

const listBalancess = `-- name: ListBalancess :many
SELECT id, statement_id, name, description, balance_type, value FROM balances
WHERE
    (
        ?1 IS NOT 0
        AND statement_id = ?1
    )
    OR
    (
        ?1 IS NULL
        AND (
            ?2 IS NULL
            OR name LIKE '%' || ?2 || '%'
        )
    )
ORDER BY
    CASE WHEN @order = 'name' AND @direction = 'asc'  THEN name END ASC,
    CASE WHEN @order = 'name' AND @direction = 'desc' THEN name END DESC,
    CASE WHEN @order = 'description' AND @direction = 'asc'  THEN description END ASC,
    CASE WHEN @order = 'description' AND @direction = 'desc' THEN description END DESC,
    CASE WHEN @order = 'balance_type' AND @direction = 'asc'  THEN balance_type END ASC,
    CASE WHEN @order = 'balance_type' AND @direction = 'desc' THEN balance_type END DESC,
    CASE WHEN @order = 'value' AND @direction = 'asc'  THEN value END ASC,
    CASE WHEN @order = 'value' AND @direction = 'desc' THEN value END DESC,
    CASE WHEN @order = 'statement_id' AND @direction = 'asc'  THEN statement_id END ASC,
    CASE WHEN @order = 'statement_id' AND @direction = 'desc' THEN statement_id END DESC,
    AND (:order IS NULL OR :order IS NOT NULL)
    AND (:direction IS NULL OR :direction IS NOT NULL)
LIMIT ?4 OFFSET ?3
`

type ListBalancessParams struct {
	StatementID interface{} `json:"statement_id"`
	Search      interface{} `json:"search"`
	Offset      int64       `json:"offset"`
	Limit       int64       `json:"limit"`
}

func (q *Queries) ListBalancess(ctx context.Context, arg ListBalancessParams) ([]Balance, error) {
	rows, err := q.db.QueryContext(ctx, listBalancess,
		arg.StatementID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Balance
	for rows.Next() {
		var i Balance
		if err := rows.Scan(
			&i.ID,
			&i.StatementID,
			&i.Name,
			&i.Description,
			&i.BalanceType,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBanks = `-- name: ListBanks :many
SELECT id, name, account_id, account_type, f_id, bank_id, branch_id
FROM banks
WHERE (
    ?1 IS NULL
    OR name         LIKE '%' || ?1 || '%'
    OR account_id   LIKE '%' || ?1 || '%'
    OR account_type LIKE '%' || ?1 || '%'
    OR f_id         LIKE '%' || ?1 || '%'
    OR bank_id      LIKE '%' || ?1 || '%'
    OR branch_id    LIKE '%' || ?1 || '%'
    AND (?2 IS NULL OR ?2 IS NOT NULL)
    AND (?3 IS NULL OR ?3 IS NOT NULL)
)
ORDER BY
    CASE WHEN :order = 'name' AND :direction = 'asc'  THEN name END ASC,
    CASE WHEN :order = 'name' AND :direction = 'desc' THEN name END DESC
LIMIT ?5 OFFSET ?4
`

type ListBanksParams struct {
	Search    interface{} `json:"search"`
	Order     interface{} `json:"order"`
	Direction interface{} `json:"direction"`
	Offset    int64       `json:"offset"`
	Limit     int64       `json:"limit"`
}

func (q *Queries) ListBanks(ctx context.Context, arg ListBanksParams) ([]Bank, error) {
	rows, err := q.db.QueryContext(ctx, listBanks,
		arg.Search,
		arg.Order,
		arg.Direction,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bank
	for rows.Next() {
		var i Bank
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountID,
			&i.AccountType,
			&i.FID,
			&i.BankID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCards = `-- name: ListCards :many
SELECT id, account_id, name, f_id FROM cards
ORDER BY name
`

func (q *Queries) ListCards(ctx context.Context) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Card
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Name,
			&i.FID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatements = `-- name: ListStatements :many
SELECT id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language FROM statements
ORDER BY start_date DESC
`

func (q *Queries) ListStatements(ctx context.Context) ([]Statement, error) {
	rows, err := q.db.QueryContext(ctx, listStatements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Statement
	for rows.Next() {
		var i Statement
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.StartDate,
			&i.EndDate,
			&i.LedgerBalance,
			&i.BalanceDate,
			&i.ServerDate,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, source_id, date, value, type, "desc" FROM transactions
ORDER BY date DESC
`

func (q *Queries) ListTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Date,
			&i.Value,
			&i.Type,
			&i.Desc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBalance = `-- name: UpdateBalance :exec
UPDATE balances
set statement_id = ?,name = ?,description = ?,balance_type = ?,value = ?
WHERE id = ?
`

type UpdateBalanceParams struct {
	StatementID sql.NullInt64  `json:"statement_id"`
	Name        interface{}    `json:"name"`
	Description sql.NullString `json:"description"`
	BalanceType interface{}    `json:"balance_type"`
	Value       float64        `json:"value"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBalance,
		arg.StatementID,
		arg.Name,
		arg.Description,
		arg.BalanceType,
		arg.Value,
		arg.ID,
	)
	return err
}

const updateBank = `-- name: UpdateBank :exec
UPDATE banks
set name = ?,account_id = ?,account_type = ?,f_id = ?,bank_id = ?,branch_id =?
WHERE id = ?
`

type UpdateBankParams struct {
	Name        interface{} `json:"name"`
	AccountID   interface{} `json:"account_id"`
	AccountType interface{} `json:"account_type"`
	FID         interface{} `json:"f_id"`
	BankID      interface{} `json:"bank_id"`
	BranchID    interface{} `json:"branch_id"`
	ID          int64       `json:"id"`
}

func (q *Queries) UpdateBank(ctx context.Context, arg UpdateBankParams) error {
	_, err := q.db.ExecContext(ctx, updateBank,
		arg.Name,
		arg.AccountID,
		arg.AccountType,
		arg.FID,
		arg.BankID,
		arg.BranchID,
		arg.ID,
	)
	return err
}

const updateCard = `-- name: UpdateCard :exec
UPDATE cards
set name =?,account_id =?,f_id =?
WHERE id = ?
`

type UpdateCardParams struct {
	Name      interface{} `json:"name"`
	AccountID interface{} `json:"account_id"`
	FID       interface{} `json:"f_id"`
	ID        int64       `json:"id"`
}

func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) error {
	_, err := q.db.ExecContext(ctx, updateCard,
		arg.Name,
		arg.AccountID,
		arg.FID,
		arg.ID,
	)
	return err
}

const updateSource = `-- name: UpdateSource :exec
UPDATE source
SET card_id = ?,bank_id = ?
WHERE id = ?
`

type UpdateSourceParams struct {
	CardID interface{} `json:"card_id"`
	BankID interface{} `json:"bank_id"`
	ID     int64       `json:"id"`
}

func (q *Queries) UpdateSource(ctx context.Context, arg UpdateSourceParams) error {
	_, err := q.db.ExecContext(ctx, updateSource, arg.CardID, arg.BankID, arg.ID)
	return err
}

const updateStatement = `-- name: UpdateStatement :exec
UPDATE statements
SET source_id = ?,start_date = ?,end_date = ?,ledger_balance = ?,balance_date = ?,server_date = ?,language = ?
WHERE id = ?
`

type UpdateStatementParams struct {
	SourceID      sql.NullInt64 `json:"source_id"`
	StartDate     interface{}   `json:"start_date"`
	EndDate       interface{}   `json:"end_date"`
	LedgerBalance float64       `json:"ledger_balance"`
	BalanceDate   interface{}   `json:"balance_date"`
	ServerDate    interface{}   `json:"server_date"`
	Language      interface{}   `json:"language"`
	ID            int64         `json:"id"`
}

func (q *Queries) UpdateStatement(ctx context.Context, arg UpdateStatementParams) error {
	_, err := q.db.ExecContext(ctx, updateStatement,
		arg.SourceID,
		arg.StartDate,
		arg.EndDate,
		arg.LedgerBalance,
		arg.BalanceDate,
		arg.ServerDate,
		arg.Language,
		arg.ID,
	)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE transactions
SET source_id = ?,date = ?,value = ?,type = ?,desc = ?
WHERE id = ?
`

type UpdateTransactionParams struct {
	SourceID sql.NullInt64  `json:"source_id"`
	Date     interface{}    `json:"date"`
	Value    float64        `json:"value"`
	Type     interface{}    `json:"type"`
	Desc     sql.NullString `json:"desc"`
	ID       interface{}    `json:"id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, updateTransaction,
		arg.SourceID,
		arg.Date,
		arg.Value,
		arg.Type,
		arg.Desc,
		arg.ID,
	)
	return err
}
