// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package databaseSQL

import (
	"context"
	"database/sql"
)

const checkStatement = `-- name: CheckStatement :one
SELECT count(id) FROM statements
WHERE id = ?1 LIMIT 1
`

func (q *Queries) CheckStatement(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkStatement, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const checkTransaction = `-- name: CheckTransaction :one
SELECT count(id) FROM transactions
WHERE id = ?1 LIMIT 1
`

func (q *Queries) CheckTransaction(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkTransaction, id)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBalances = `-- name: CountBalances :one
SELECT count(id) FROM balances
WHERE
    (
        ?1 IS NOT NULL
        AND statement_id = ?1
    )
    OR
    (
        ?1 IS NULL
        AND (
            ?2 IS NULL
            OR name LIKE '%' || ?2 || '%'
        )
    )
`

type CountBalancesParams struct {
	StatementID interface{} `json:"statement_id"`
	Search      interface{} `json:"search"`
}

func (q *Queries) CountBalances(ctx context.Context, arg CountBalancesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBalances, arg.StatementID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countBanks = `-- name: CountBanks :one
SELECT count(id)
FROM banks
WHERE (
    ?1 IS NULL
    OR name LIKE '%' || ?1 || '%'
    OR account_id LIKE '%' || ?1 || '%'
    OR account_type LIKE '%' || ?1 || '%'
    OR f_id LIKE '%' || ?1 || '%'
    OR bank_id LIKE '%' || ?1 || '%'
    OR branch_id LIKE '%' || ?1 || '%'
)
`

func (q *Queries) CountBanks(ctx context.Context, search interface{}) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBanks, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countStatements = `-- name: CountStatements :one
SELECT count(id) FROM statements
WHERE source_id = ?1
AND (
    ?2 IS NULL
    OR balance_date LIKE '%' || ?2 || '%'
    OR server_date LIKE '%' || ?2 || '%'
    OR language LIKE '%' || ?2 || '%'
)
AND (
    ?3 IS NULL
    OR ledger_balance <= ?3
)
AND (
    ?4 IS NULL
    OR ledger_balance >= ?4
)
AND (
    ?5 IS NULL
    OR start_date >= ?5
)
AND (
    ?6 IS NULL
    OR start_date <= ?6
)
`

type CountStatementsParams struct {
	SourceID       int64       `json:"source_id"`
	Search         interface{} `json:"search"`
	SearchMaxValue interface{} `json:"searchMaxValue"`
	SearchMinValue interface{} `json:"searchMinValue"`
	SearchFrom     interface{} `json:"searchFrom"`
	SearchTo       interface{} `json:"searchTo"`
}

func (q *Queries) CountStatements(ctx context.Context, arg CountStatementsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStatements,
		arg.SourceID,
		arg.Search,
		arg.SearchMaxValue,
		arg.SearchMinValue,
		arg.SearchFrom,
		arg.SearchTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTransactions = `-- name: CountTransactions :one
SELECT count(id)
FROM transactions
WHERE source_id = ?1
AND (
    ?2 IS NULL
    OR date LIKE '%' || ?2 || '%'
    OR "desc" LIKE '%' || ?2 || '%'
)
AND (
    ?3 IS NULL
    OR type LIKE '%' || ?3 || '%'
)
AND (
    ?4 IS NULL
    OR value <= ?4
)
AND (
    ?5 IS NULL
    OR value >= ?5
)
AND (
    ?6 IS NULL
    OR date >= ?6
)
AND (
    ?7 IS NULL
    OR date <= ?7
)
`

type CountTransactionsParams struct {
	SourceID       int64       `json:"source_id"`
	Search         interface{} `json:"search"`
	SearchType     interface{} `json:"searchType"`
	SearchMaxValue interface{} `json:"searchMaxValue"`
	SearchMinValue interface{} `json:"searchMinValue"`
	SearchFrom     interface{} `json:"searchFrom"`
	SearchTo       interface{} `json:"searchTo"`
}

func (q *Queries) CountTransactions(ctx context.Context, arg CountTransactionsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTransactions,
		arg.SourceID,
		arg.Search,
		arg.SearchType,
		arg.SearchMaxValue,
		arg.SearchMinValue,
		arg.SearchFrom,
		arg.SearchTo,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBalance = `-- name: CreateBalance :one
INSERT INTO balances (
    statement_id, name, description, balance_type, value
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, statement_id, name, description, balance_type, value
`

type CreateBalanceParams struct {
	StatementID int64          `json:"statement_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	BalanceType string         `json:"balance_type"`
	Value       float64        `json:"value"`
}

func (q *Queries) CreateBalance(ctx context.Context, arg CreateBalanceParams) (Balance, error) {
	row := q.db.QueryRowContext(ctx, createBalance,
		arg.StatementID,
		arg.Name,
		arg.Description,
		arg.BalanceType,
		arg.Value,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.StatementID,
		&i.Name,
		&i.Description,
		&i.BalanceType,
		&i.Value,
	)
	return i, err
}

const createBank = `-- name: CreateBank :one
INSERT INTO banks (
    name, account_id, account_type, f_id, bank_id, branch_id
) VALUES (
    ?, ?, ?, ?, ?, ?
)
RETURNING id, name, account_id, account_type, f_id, bank_id, branch_id
`

type CreateBankParams struct {
	Name        string `json:"name"`
	AccountID   string `json:"account_id"`
	AccountType string `json:"account_type"`
	FID         string `json:"f_id"`
	BankID      string `json:"bank_id"`
	BranchID    string `json:"branch_id"`
}

func (q *Queries) CreateBank(ctx context.Context, arg CreateBankParams) (Bank, error) {
	row := q.db.QueryRowContext(ctx, createBank,
		arg.Name,
		arg.AccountID,
		arg.AccountType,
		arg.FID,
		arg.BankID,
		arg.BranchID,
	)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountID,
		&i.AccountType,
		&i.FID,
		&i.BankID,
		&i.BranchID,
	)
	return i, err
}

const createCard = `-- name: CreateCard :one
INSERT INTO cards (
    name, account_id, f_id
) VALUES (
    ?, ?, ?
)
RETURNING id, account_id, name, f_id
`

type CreateCardParams struct {
	Name      string `json:"name"`
	AccountID string `json:"account_id"`
	FID       string `json:"f_id"`
}

func (q *Queries) CreateCard(ctx context.Context, arg CreateCardParams) (Card, error) {
	row := q.db.QueryRowContext(ctx, createCard, arg.Name, arg.AccountID, arg.FID)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.FID,
	)
	return i, err
}

const createSource = `-- name: CreateSource :one
INSERT INTO source (
    card_id, bank_id
) VALUES (
    ?, ?
)
RETURNING id, card_id, bank_id
`

type CreateSourceParams struct {
	CardID sql.NullInt64 `json:"card_id"`
	BankID sql.NullInt64 `json:"bank_id"`
}

func (q *Queries) CreateSource(ctx context.Context, arg CreateSourceParams) (Source, error) {
	row := q.db.QueryRowContext(ctx, createSource, arg.CardID, arg.BankID)
	var i Source
	err := row.Scan(&i.ID, &i.CardID, &i.BankID)
	return i, err
}

const createStatement = `-- name: CreateStatement :one
INSERT INTO statements (
    source_id, start_date, end_date, ledger_balance, balance_date, server_date, language
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language
`

type CreateStatementParams struct {
	SourceID      int64   `json:"source_id"`
	StartDate     string  `json:"start_date"`
	EndDate       string  `json:"end_date"`
	LedgerBalance float64 `json:"ledger_balance"`
	BalanceDate   string  `json:"balance_date"`
	ServerDate    string  `json:"server_date"`
	Language      string  `json:"language"`
}

func (q *Queries) CreateStatement(ctx context.Context, arg CreateStatementParams) (Statement, error) {
	row := q.db.QueryRowContext(ctx, createStatement,
		arg.SourceID,
		arg.StartDate,
		arg.EndDate,
		arg.LedgerBalance,
		arg.BalanceDate,
		arg.ServerDate,
		arg.Language,
	)
	var i Statement
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.StartDate,
		&i.EndDate,
		&i.LedgerBalance,
		&i.BalanceDate,
		&i.ServerDate,
		&i.Language,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    id, source_id, date, value, type, desc
) VALUES (
    ?, ?, ?, ?, ?, ?
)
RETURNING id, source_id, date, value, type, "desc"
`

type CreateTransactionParams struct {
	ID       string  `json:"id"`
	SourceID int64   `json:"source_id"`
	Date     string  `json:"date"`
	Value    float64 `json:"value"`
	Type     string  `json:"type"`
	Desc     string  `json:"desc"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.ID,
		arg.SourceID,
		arg.Date,
		arg.Value,
		arg.Type,
		arg.Desc,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Date,
		&i.Value,
		&i.Type,
		&i.Desc,
	)
	return i, err
}

const deleteBalance = `-- name: DeleteBalance :exec
DELETE FROM balances
WHERE id = ?
`

func (q *Queries) DeleteBalance(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBalance, id)
	return err
}

const deleteBank = `-- name: DeleteBank :exec
DELETE FROM banks
WHERE id = ?
`

func (q *Queries) DeleteBank(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBank, id)
	return err
}

const deleteCard = `-- name: DeleteCard :exec
DELETE FROM cards
WHERE id = ?
`

func (q *Queries) DeleteCard(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCard, id)
	return err
}

const deleteSource = `-- name: DeleteSource :exec
DELETE FROM source
WHERE id = ?
`

func (q *Queries) DeleteSource(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSource, id)
	return err
}

const deleteStatement = `-- name: DeleteStatement :exec
DELETE FROM statements
WHERE id = ?
`

func (q *Queries) DeleteStatement(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteStatement, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions
WHERE id = ?
`

func (q *Queries) DeleteTransaction(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTransaction, id)
	return err
}

const findBalance = `-- name: FindBalance :one
SELECT id FROM balances
WHERE statement_id = ? AND name = ? AND value = ?
LIMIT 1
`

type FindBalanceParams struct {
	StatementID int64   `json:"statement_id"`
	Name        string  `json:"name"`
	Value       float64 `json:"value"`
}

// Balances
func (q *Queries) FindBalance(ctx context.Context, arg FindBalanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findBalance, arg.StatementID, arg.Name, arg.Value)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const findSource = `-- name: FindSource :one
SELECT id
FROM source
WHERE (bank_id = ?1 AND card_id IS NULL)
   OR (bank_id IS NULL AND card_id = ?2)
LIMIT 1
`

type FindSourceParams struct {
	BankID sql.NullInt64 `json:"bank_id"`
	CardID sql.NullInt64 `json:"card_id"`
}

func (q *Queries) FindSource(ctx context.Context, arg FindSourceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, findSource, arg.BankID, arg.CardID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getBank = `-- name: GetBank :one
SELECT id, name, account_id, account_type, f_id, bank_id, branch_id FROM banks
WHERE id = ? LIMIT 1
`

// Banks
func (q *Queries) GetBank(ctx context.Context, id int64) (Bank, error) {
	row := q.db.QueryRowContext(ctx, getBank, id)
	var i Bank
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AccountID,
		&i.AccountType,
		&i.FID,
		&i.BankID,
		&i.BranchID,
	)
	return i, err
}

const getBankIdByAccountId = `-- name: GetBankIdByAccountId :one
SELECT id FROM banks
WHERE account_id = ? LIMIT 1
`

func (q *Queries) GetBankIdByAccountId(ctx context.Context, accountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getBankIdByAccountId, accountID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCard = `-- name: GetCard :one
SELECT id, account_id, name, f_id FROM cards
WHERE id = ? LIMIT 1
`

// Cards
func (q *Queries) GetCard(ctx context.Context, id int64) (Card, error) {
	row := q.db.QueryRowContext(ctx, getCard, id)
	var i Card
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Name,
		&i.FID,
	)
	return i, err
}

const getCardIdByAccountId = `-- name: GetCardIdByAccountId :one
SELECT id FROM cards
WHERE account_id = ?1 LIMIT 1
`

func (q *Queries) GetCardIdByAccountId(ctx context.Context, accountID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCardIdByAccountId, accountID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getCurrentBalanceQuery = `-- name: GetCurrentBalanceQuery :one
SELECT id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language
FROM statements
WHERE source_id = ?
ORDER BY balance_date DESC
LIMIT 1
`

func (q *Queries) GetCurrentBalanceQuery(ctx context.Context, sourceID int64) (Statement, error) {
	row := q.db.QueryRowContext(ctx, getCurrentBalanceQuery, sourceID)
	var i Statement
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.StartDate,
		&i.EndDate,
		&i.LedgerBalance,
		&i.BalanceDate,
		&i.ServerDate,
		&i.Language,
	)
	return i, err
}

const getLargestBalanceQuery = `-- name: GetLargestBalanceQuery :one
SELECT id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language
FROM statements
WHERE source_id = ?
ORDER BY ledger_balance DESC
LIMIT 1
`

func (q *Queries) GetLargestBalanceQuery(ctx context.Context, sourceID int64) (Statement, error) {
	row := q.db.QueryRowContext(ctx, getLargestBalanceQuery, sourceID)
	var i Statement
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.StartDate,
		&i.EndDate,
		&i.LedgerBalance,
		&i.BalanceDate,
		&i.ServerDate,
		&i.Language,
	)
	return i, err
}

const getSources = `-- name: GetSources :many
SELECT source.id, cards.name
FROM source
JOIN cards ON cards.id = source.card_id
UNION ALL
SELECT source.id, banks.name
FROM source
JOIN banks ON banks.id = source.bank_id
`

type GetSourcesRow struct {
	ID   int64  `json:"id"`
	Name string `json:"name"`
}

// Source
func (q *Queries) GetSources(ctx context.Context) ([]GetSourcesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSourcesRow
	for rows.Next() {
		var i GetSourcesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStatement = `-- name: GetStatement :one
SELECT id FROM statements
WHERE start_date = ? AND end_date = ? AND ledger_balance = ?
LIMIT 1
`

type GetStatementParams struct {
	StartDate     string  `json:"start_date"`
	EndDate       string  `json:"end_date"`
	LedgerBalance float64 `json:"ledger_balance"`
}

// Statements
func (q *Queries) GetStatement(ctx context.Context, arg GetStatementParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStatement, arg.StartDate, arg.EndDate, arg.LedgerBalance)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, source_id, date, value, type, "desc" FROM transactions
WHERE id = ?1 LIMIT 1
`

// Transactions
func (q *Queries) GetTransaction(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.Date,
		&i.Value,
		&i.Type,
		&i.Desc,
	)
	return i, err
}

const listBalances = `-- name: ListBalances :many
SELECT id, statement_id, name, description, balance_type, value FROM balances
WHERE
    (
        ?1 IS NOT NULL
        AND statement_id = ?1
    )
    OR
    (
        ?1 IS NULL
        AND (
            ?2 IS NULL
            OR name LIKE '%' || ?2 || '%'
        )
    )
LIMIT ?4 OFFSET ?3
`

type ListBalancesParams struct {
	StatementID interface{} `json:"statement_id"`
	Search      interface{} `json:"search"`
	Offset      int64       `json:"offset"`
	Limit       int64       `json:"limit"`
}

func (q *Queries) ListBalances(ctx context.Context, arg ListBalancesParams) ([]Balance, error) {
	rows, err := q.db.QueryContext(ctx, listBalances,
		arg.StatementID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Balance
	for rows.Next() {
		var i Balance
		if err := rows.Scan(
			&i.ID,
			&i.StatementID,
			&i.Name,
			&i.Description,
			&i.BalanceType,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBanks = `-- name: ListBanks :many
SELECT id, name, account_id, account_type, f_id, bank_id, branch_id
FROM banks
WHERE (
    ?1 IS NULL
    OR name LIKE '%' || ?1 || '%'
    OR account_id LIKE '%' || ?1 || '%'
    OR account_type LIKE '%' || ?1 || '%'
    OR f_id LIKE '%' || ?1 || '%'
    OR bank_id LIKE '%' || ?1 || '%'
    OR branch_id LIKE '%' || ?1 || '%'
)
ORDER BY id DESC
LIMIT ?3 OFFSET ?2
`

type ListBanksParams struct {
	Search interface{} `json:"search"`
	Offset int64       `json:"offset"`
	Limit  int64       `json:"limit"`
}

func (q *Queries) ListBanks(ctx context.Context, arg ListBanksParams) ([]Bank, error) {
	rows, err := q.db.QueryContext(ctx, listBanks, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bank
	for rows.Next() {
		var i Bank
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AccountID,
			&i.AccountType,
			&i.FID,
			&i.BankID,
			&i.BranchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStatements = `-- name: ListStatements :many
SELECT id, source_id, start_date, end_date, ledger_balance, balance_date, server_date, language FROM statements
WHERE source_id = ?1
AND (
    ?2 IS NULL
    OR balance_date LIKE '%' || ?2 || '%'
    OR server_date LIKE '%' || ?2 || '%'
    OR language LIKE '%' || ?2 || '%'
)
AND (
    ?3 IS NULL
    OR ledger_balance <= ?3
)
AND (
    ?4 IS NULL
    OR ledger_balance >= ?4
)
AND (
    ?5 IS NULL
    OR start_date >= ?5
)
AND (
    ?6 IS NULL
    OR start_date <= ?6
)
ORDER BY start_date DESC
LIMIT ?8 OFFSET ?7
`

type ListStatementsParams struct {
	SourceID       int64       `json:"source_id"`
	Search         interface{} `json:"search"`
	SearchMaxValue interface{} `json:"searchMaxValue"`
	SearchMinValue interface{} `json:"searchMinValue"`
	SearchFrom     interface{} `json:"searchFrom"`
	SearchTo       interface{} `json:"searchTo"`
	Offset         int64       `json:"offset"`
	Limit          int64       `json:"limit"`
}

func (q *Queries) ListStatements(ctx context.Context, arg ListStatementsParams) ([]Statement, error) {
	rows, err := q.db.QueryContext(ctx, listStatements,
		arg.SourceID,
		arg.Search,
		arg.SearchMaxValue,
		arg.SearchMinValue,
		arg.SearchFrom,
		arg.SearchTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Statement
	for rows.Next() {
		var i Statement
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.StartDate,
			&i.EndDate,
			&i.LedgerBalance,
			&i.BalanceDate,
			&i.ServerDate,
			&i.Language,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, source_id, date, value, type, "desc"
FROM transactions
WHERE source_id = ?1
AND (
    ?2 IS NULL
    OR date LIKE '%' || ?2 || '%'
    OR "desc" LIKE '%' || ?2 || '%'
)
AND (
    ?3 IS NULL
    OR type LIKE '%' || ?3 || '%'
)
AND (
    ?4 IS NULL
    OR value <= ?4
)
AND (
    ?5 IS NULL
    OR value >= ?5
)
AND (
    ?6 IS NULL
    OR date >= ?6
)
AND (
    ?7 IS NULL
    OR date <= ?7
)
ORDER BY date DESC
LIMIT ?9 OFFSET ?8
`

type ListTransactionsParams struct {
	SourceID       int64       `json:"source_id"`
	Search         interface{} `json:"search"`
	SearchType     interface{} `json:"searchType"`
	SearchMaxValue interface{} `json:"searchMaxValue"`
	SearchMinValue interface{} `json:"searchMinValue"`
	SearchFrom     interface{} `json:"searchFrom"`
	SearchTo       interface{} `json:"searchTo"`
	Offset         int64       `json:"offset"`
	Limit          int64       `json:"limit"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactions,
		arg.SourceID,
		arg.Search,
		arg.SearchType,
		arg.SearchMaxValue,
		arg.SearchMinValue,
		arg.SearchFrom,
		arg.SearchTo,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Transaction
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.Date,
			&i.Value,
			&i.Type,
			&i.Desc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transactionsInfo = `-- name: TransactionsInfo :one
SELECT
    COALESCE(SUM(CASE WHEN value > ? THEN value ELSE 0 END), 0) AS positive,
    COALESCE(SUM(CASE WHEN value < ? THEN value ELSE 0 END), 0) AS negative,
    COALESCE(SUM(value), 0) AS value
FROM transactions
WHERE source_id = ?
LIMIT 1
`

type TransactionsInfoParams struct {
	Value    float64 `json:"value"`
	Value_2  float64 `json:"value_2"`
	SourceID int64   `json:"source_id"`
}

type TransactionsInfoRow struct {
	Positive interface{} `json:"positive"`
	Negative interface{} `json:"negative"`
	Value    interface{} `json:"value"`
}

func (q *Queries) TransactionsInfo(ctx context.Context, arg TransactionsInfoParams) (TransactionsInfoRow, error) {
	row := q.db.QueryRowContext(ctx, transactionsInfo, arg.Value, arg.Value_2, arg.SourceID)
	var i TransactionsInfoRow
	err := row.Scan(&i.Positive, &i.Negative, &i.Value)
	return i, err
}

const updateBalance = `-- name: UpdateBalance :exec
UPDATE balances
SET statement_id = ?, name = ?, description = ?, balance_type = ?, value = ?
WHERE id = ?
`

type UpdateBalanceParams struct {
	StatementID int64          `json:"statement_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	BalanceType string         `json:"balance_type"`
	Value       float64        `json:"value"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBalance,
		arg.StatementID,
		arg.Name,
		arg.Description,
		arg.BalanceType,
		arg.Value,
		arg.ID,
	)
	return err
}

const updateBankName = `-- name: UpdateBankName :exec
UPDATE banks
SET name = ?
WHERE id = ?
`

type UpdateBankNameParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

func (q *Queries) UpdateBankName(ctx context.Context, arg UpdateBankNameParams) error {
	_, err := q.db.ExecContext(ctx, updateBankName, arg.Name, arg.ID)
	return err
}

const updateCard = `-- name: UpdateCard :exec
UPDATE cards
SET name = ?, account_id = ?, f_id = ?
WHERE id = ?
`

type UpdateCardParams struct {
	Name      string `json:"name"`
	AccountID string `json:"account_id"`
	FID       string `json:"f_id"`
	ID        int64  `json:"id"`
}

func (q *Queries) UpdateCard(ctx context.Context, arg UpdateCardParams) error {
	_, err := q.db.ExecContext(ctx, updateCard,
		arg.Name,
		arg.AccountID,
		arg.FID,
		arg.ID,
	)
	return err
}

const updateSource = `-- name: UpdateSource :exec
UPDATE source
SET bank_id = ?, card_id = ?
WHERE id = ?
`

type UpdateSourceParams struct {
	BankID sql.NullInt64 `json:"bank_id"`
	CardID sql.NullInt64 `json:"card_id"`
	ID     int64         `json:"id"`
}

func (q *Queries) UpdateSource(ctx context.Context, arg UpdateSourceParams) error {
	_, err := q.db.ExecContext(ctx, updateSource, arg.BankID, arg.CardID, arg.ID)
	return err
}

const updateStatement = `-- name: UpdateStatement :exec
UPDATE statements
SET source_id = ?, start_date = ?, end_date = ?, ledger_balance = ?, balance_date = ?, server_date = ?, language = ?
WHERE id = ?
`

type UpdateStatementParams struct {
	SourceID      int64   `json:"source_id"`
	StartDate     string  `json:"start_date"`
	EndDate       string  `json:"end_date"`
	LedgerBalance float64 `json:"ledger_balance"`
	BalanceDate   string  `json:"balance_date"`
	ServerDate    string  `json:"server_date"`
	Language      string  `json:"language"`
	ID            int64   `json:"id"`
}

func (q *Queries) UpdateStatement(ctx context.Context, arg UpdateStatementParams) error {
	_, err := q.db.ExecContext(ctx, updateStatement,
		arg.SourceID,
		arg.StartDate,
		arg.EndDate,
		arg.LedgerBalance,
		arg.BalanceDate,
		arg.ServerDate,
		arg.Language,
		arg.ID,
	)
	return err
}

const updateTransaction = `-- name: UpdateTransaction :exec
UPDATE transactions
SET source_id = ?, date = ?, value = ?, type = ?, desc = ?
WHERE id = ?
`

type UpdateTransactionParams struct {
	SourceID int64   `json:"source_id"`
	Date     string  `json:"date"`
	Value    float64 `json:"value"`
	Type     string  `json:"type"`
	Desc     string  `json:"desc"`
	ID       string  `json:"id"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, updateTransaction,
		arg.SourceID,
		arg.Date,
		arg.Value,
		arg.Type,
		arg.Desc,
		arg.ID,
	)
	return err
}
